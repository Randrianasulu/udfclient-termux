Only in /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/: .o
Only in /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/: Makefile
diff -r -U 8 -x configure UDFclient.0.8.11/Makefile.in /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/Makefile.in
--- UDFclient.0.8.11/Makefile.in	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/Makefile.in	2021-11-28 21:34:34.483029098 +0300
@@ -73,16 +73,16 @@
 	rm -f Makefile
 
 libuscsi.a: $(USCSILIB)
 	ar -rsc libuscsi.a $(USCSILIB)
 
 libudf.a: $(LIB)
 	ar -rsc libudf.a $(LIB)
 
-$(SCSI_APPS): $(.TARGET).o libuscsi.a
-	$(LD) -o $(.TARGET) $(LDFLAGS) $(.TARGET).o libuscsi.a $(POSTOBJ)
+$(SCSI_APPS): $@.o libuscsi.a
+	$(LD) -o $@ $(LDFLAGS) $@.c libuscsi.a $(POSTOBJ)
 
-$(APPS): $(.TARGET).o libuscsi.a libudf.a
-	$(LD) -o $(.TARGET) $(LDFLAGS) $(.TARGET).o libudf.a libuscsi.a $(POSTOBJ)
+$(APPS): $@.o libuscsi.a libudf.a
+	$(LD) -o $@ $(CPPFLAGS) $(LDFLAGS) $@.c libudf.a libuscsi.a $(POSTOBJ)
 
 
 # DO NOT DELETE
diff -r -U 8 -x configure UDFclient.0.8.11/dirhash.h /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/dirhash.h
--- UDFclient.0.8.11/dirhash.h	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/dirhash.h	2021-11-28 21:20:55.599029049 +0300
@@ -34,16 +34,18 @@
 #ifndef DIRHASH_SIZE
 #define	DIRHASH_SIZE	(1024*1024)
 #endif
 
 #define	DIRHASH_HASHBITS	5
 #define	DIRHASH_HASHSIZE	(1 << DIRHASH_HASHBITS)
 #define	DIRHASH_HASHMASK	(DIRHASH_HASHSIZE - 1)
 
+
+
 #ifdef NO_DIRENT_NAMLEN
 #	define DIRENT_NAMLEN(d) strlen((d)->d_name)
 #else
 #	define DIRENT_NAMLEN(d) (d)->d_namlen
 #endif
 
 
 #ifndef _DIRENT_SIZE
Only in /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/: disk
diff -r -U 8 -x configure UDFclient.0.8.11/newfs_udf.c /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/newfs_udf.c
--- UDFclient.0.8.11/newfs_udf.c	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/newfs_udf.c	2021-11-28 21:40:17.519029118 +0300
@@ -441,19 +441,19 @@
 			root_node->udf_log_vol->num_directories++;
 			udf_insert_node_in_hash(root_node);
 			udf_node_mark_dirty(root_node);
 
 			/* note creation times */
 #ifndef NO_STAT_BIRTHTIME
 			udf_set_timespec_now(&root_node->stat.st_birthtimespec);
 #endif
-			udf_set_timespec_now(&root_node->stat.st_atimespec);
-			udf_set_timespec_now(&root_node->stat.st_ctimespec);
-			udf_set_timespec_now(&root_node->stat.st_mtimespec);
+			udf_set_timespec_now(&root_node->stat.st_atim);
+			udf_set_timespec_now(&root_node->stat.st_ctim);
+			udf_set_timespec_now(&root_node->stat.st_mtim);
 
 			dscr_entry = TAILQ_FIRST(&root_node->dscr_allocs);
 			fileset->rootdir_icb.loc.lb_num   = udf_rw32(dscr_entry->lb_num);
 			fileset->rootdir_icb.loc.part_num = udf_rw16(dscr_entry->vpart_num);
 			fileset->rootdir_icb.len          = udf_rw32(lb_size);			/* FIXME type 4096? */
 
 			/* set all to writable or we're in trouble here */
 			udf_log_vol->logvol_state = UDF_INTEGRITY_OPEN;
diff -r -U 8 -x configure UDFclient.0.8.11/udf.c /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/udf.c
--- UDFclient.0.8.11/udf.c	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/udf.c	2021-11-28 21:20:34.307029048 +0300
@@ -3448,17 +3448,17 @@
 
 /* can be passed either a file_entry or an extfil_entry trough fentry! */
 int udf_check_for_vat(struct udf_log_vol *udf_log_vol, struct udf_part_mapping *part_mapping, uint32_t vat_lb, union dscrptr *dscr) {
 	struct udf_part_mapping *s_part_mapping;
 	struct udf_node		*vat_udf_node;
 	struct long_ad		 udf_icbptr;
 	struct regid 		*regid;
 	struct uio		 vat_uio;
-	struct iovec		 vat_iovec;
+	struct myiovec		 vat_iovec;
 	struct icb_tag		*icbtag;
 	struct timestamp	*mtime;
 	uint64_t		 vat_length, vat_entries;
 	uint32_t		*vat_pos, vpart_num;
 	uint8_t			*vat;
 	int			 error, found;
 
 	/* prepare a `uio' structure for reading in complete VAT file */
@@ -5424,17 +5424,17 @@
 	*phas_fids = has_fids;
 }
 
 
 /* read one fid and process it into a dirent and advance to the next */
 /* (*fid) has to be allocated a logical block in size, (*dirent) struct dirent length */
 int udf_read_fid_stream(struct udf_node *dir_node, uint64_t *offset, struct fileid_desc *fid, struct dirent *dirent) {
 	struct uio     dir_uio;
-	struct iovec   dir_iovec;
+	struct myiovec   dir_iovec;
 	char          *fid_name;
 	uint32_t       entry_length, lb_size;
 	int            enough, error;
 
 	assert(fid);
 	assert(dirent);
 	assert(dir_node);
 	assert(offset);
@@ -5787,17 +5787,17 @@
 	free(fid);
 
 	return 0;
 }
 
 
 static int udf_writeout_fid_info(struct udf_node *dir_node, struct fileid_desc *fid, uint64_t offset, uint16_t fid_len) {
 	struct uio     uio;
-	struct iovec   iovec;
+	struct myiovec   iovec;
 	int flags;
 
 	bzero(&uio, sizeof(struct uio));
 	uio.uio_rw     = UIO_READ;	/* read from this space */
 	uio.uio_iovcnt = 1;
 	uio.uio_iov    = &iovec;
 	iovec.iov_base = fid;
 	iovec.iov_len  = fid_len;
diff -r -U 8 -x configure UDFclient.0.8.11/udf_verbose.c /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/udf_verbose.c
--- UDFclient.0.8.11/udf_verbose.c	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/udf_verbose.c	2021-11-28 21:20:34.311029048 +0300
@@ -1325,17 +1325,17 @@
  * extern defined read_logvol_descriptor breaks splitting rules but how
  * otherwise to provide a detailed description of the file entry udf_node
  */
 
 #define DUMP_DIRBUFFER_SIZE (16*1024)
 void udf_dump_file_entry_node(struct udf_node *udf_node, char *prefix) {
 	struct long_ad   udf_icbptr;
 	struct uio       dir_uio;
-	struct iovec     dir_iovec;
+	struct myiovec     dir_iovec;
 	struct dirent   *dirent;
 	struct fileid_desc *fid;
 	struct udf_node *entry_node;
 	uint32_t         pos, lb_size;
 	uint8_t         *buffer;
 	char             fullpath[1024];	/* XXX arbitrary length XXX */
 	int              isdot, isdotdot, isdir, found, eof;
 	int		 error;
diff -r -U 8 -x configure UDFclient.0.8.11/udfclient.c /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/udfclient.c
--- UDFclient.0.8.11/udfclient.c	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/udfclient.c	2021-11-28 21:24:45.191029063 +0300
@@ -38,16 +38,17 @@
 #include <limits.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <errno.h>
 #include "udf.h"
 #include "udf_bswap.h"
 
+
 /* switches */
 
 /* #define DEBUG(a) (a) */
 #define DEBUG(a) if (0) { a; }
 
 
 #ifndef MAX
 #define MAX(a,b) ((a)>(b)?(a):(b))
@@ -320,17 +321,17 @@
 }
 
 
 #define LS_SUBTREE_DIR_BUFFER_SIZE (16*1024)
 void udfclient_ls(int args, char *arg1) {
 	struct udf_node *udf_node, *entry_node;
 	uint8_t       *buffer;
 	struct uio     dir_uio;
-	struct iovec   dir_uiovec;
+	struct myiovec   dir_uiovec;
 	struct dirent *dirent;
 	struct stat    stat;
 	uint32_t       pos;
 	int            eof;
 	char          *node_name, *leaf_name;
 	int            error;
 
 	if (args > 1) {
@@ -564,17 +565,17 @@
 	gettimeofday(&tp, NULL);
 	return 1000000*tp.tv_sec + tp.tv_usec;
 }
 
 
 
 int udfclient_get_file(struct udf_node *udf_node, char *fullsrcname, char *fulldstname) {
 	struct uio	 file_uio;
-	struct iovec	 file_iov;
+	struct myiovec	 file_iov;
 	struct stat	 stat;
 	struct timeval	 times[2];
 	uint64_t	 file_length;
 	uint64_t 	 start, now, then, eta;
 	uint64_t	 cur_speed, avg_speed, data_transfered;
 	uint64_t	 file_block_size, file_transfer_size, written;
 	uint8_t		*file_block;
 	char		 cur_txt[32], avg_txt[32], eta_txt[32];
@@ -598,18 +599,18 @@
 
 		error = mkdir(fulldstname, (udf_node->stat.st_mode) & 07777);
 		if (!error) {
 			/* set owner attribute and times; access permissions allready set on creation.*/
 			notok = chown(fulldstname, stat.st_uid, stat.st_gid);
 			if (notok && (udf_verbose > UDF_VERBLEV_ACTIONS))
 				fprintf(stderr, "failed to set owner of directory, ignoring\n");
 
-			TIMESPEC_TO_TIMEVAL(&times[0], &stat.st_atimespec);	/* access time		*/
-			TIMESPEC_TO_TIMEVAL(&times[1], &stat.st_mtimespec);	/* modification time	*/
+			TIMESPEC_TO_TIMEVAL(&times[0], &stat.st_atim);	/* access time		*/
+			TIMESPEC_TO_TIMEVAL(&times[1], &stat.st_mtim);	/* modification time	*/
 			notok = utimes(fulldstname, times);
 			if (notok)
 				fprintf(stderr, "failed to set times on directory, ignoring\n");
 		}
 		if (error)
 			fprintf(stderr, "While creating directory `%s' : %s\n", fulldstname, strerror(errno));
 
 		return 0;
@@ -685,35 +686,35 @@
 		printf(" finished\n");
 		free(file_block);
 
 		/* set owner attribute and times; access permissions allready set on creation.*/
 		notok = fchown(fileh, stat.st_uid, stat.st_gid);
 		if (notok && (udf_verbose > UDF_VERBLEV_ACTIONS))
 			fprintf(stderr, "failed to set owner of file, ignoring\n");
 
-		TIMESPEC_TO_TIMEVAL(&times[0], &stat.st_atimespec);	/* access time		*/
-		TIMESPEC_TO_TIMEVAL(&times[1], &stat.st_mtimespec);	/* modification time	*/
+		TIMESPEC_TO_TIMEVAL(&times[0], &stat.st_atim);	/* access time		*/
+		TIMESPEC_TO_TIMEVAL(&times[1], &stat.st_mtim);	/* modification time	*/
 		notok = futimes(fileh, times);
 		if (notok)
 			fprintf(stderr, "failed to set times on directory, ignoring\n");
 
 		close(fileh);
 	} else {
 		printf("Help! can't open file %s for output\n", fulldstname);
 	}
 
 	return error;
 }
 
 
 #define GET_SUBTREE_DIR_BUFFER_SIZE (16*1024)
 void udfclient_get_subtree(struct udf_node *udf_node, char *srcprefix, char *dstprefix, int recurse, uint64_t *total_size) {
 	struct uio          dir_uio;
-	struct iovec        dir_iovec;
+	struct myiovec        dir_iovec;
 	uint8_t            *buffer;
 	uint32_t            pos;
 	char                fullsrcpath[1024], fulldstpath[1024];	/* XXX arbitrary length XXX */
 	struct dirent      *dirent;
 	struct stat         stat;
 	struct udf_node    *entry_node;
 	struct fileid_desc *fid;
 	struct long_ad      udf_icbptr;
@@ -895,17 +896,17 @@
 
 	if (node_name)
 		free(node_name);
 }
 
 
 int udfclient_put_file(struct udf_node *udf_node, char *fullsrcname, char *fulldstname) {
 	struct uio	 file_uio;
-	struct iovec	 file_iov;
+	struct myiovec	 file_iov;
 	uint64_t	 file_length;
 	uint64_t 	 start, now, then, eta;
 	uint64_t	 cur_speed, avg_speed, data_transfered;
 	uint64_t	 file_block_size, file_transfer_size;
 	uint8_t		*file_block;
 	char		 cur_txt[32], avg_txt[32], eta_txt[32];
 	int		 fileh;
 	int   		 error, printed;
@@ -1216,17 +1217,17 @@
 		udf_sync_disc(udf_disc);
 	}
 }
 
 
 #define RM_SUBTREE_DIR_BUFFER_SIZE (32*1024)
 int udfclient_rm_subtree(struct udf_node *parent_node, struct udf_node *dir_node, char *name, char *full_parent_name) {
 	struct uio          dir_uio;
-	struct iovec        dir_iovec;
+	struct myiovec        dir_iovec;
 	uint8_t            *buffer;
 	uint32_t            pos;
 	char               *fullpath;
 	struct dirent      *dirent;
 	struct stat         stat;
 	struct udf_node    *entry_node;
 	struct fileid_desc *fid;
 	struct long_ad      udf_icbptr;
diff -r -U 8 -x configure UDFclient.0.8.11/uio.c /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/uio.c
--- UDFclient.0.8.11/uio.c	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/uio.c	2021-11-28 21:20:34.319029048 +0300
@@ -31,17 +31,17 @@
 
 #include <assert.h>
 #include <string.h>
 #include "uio.h"
 
 
 /* modelled after NetBSD's uiomove */
 int uiomove(void *buf, size_t amount, struct uio *uio) {
-	struct	iovec *iov;
+	struct	myiovec *iov;
 	char	*cp = buf;
 	size_t	cnt;
 
 	assert(buf);
 	assert(uio);
 	assert(uio->uio_iov);
 
 	while (amount > 0 && uio->uio_resid > 0) {
diff -r -U 8 -x configure UDFclient.0.8.11/uio.h /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/uio.h
--- UDFclient.0.8.11/uio.h	2020-04-18 13:05:40.000000000 +0300
+++ /data/data/com.termux/files/home/udfclient/UDFclient.0.8.11/uio.h	2021-11-28 21:20:34.323029048 +0300
@@ -38,35 +38,35 @@
 /* define an uio structure for fragmenting reading in and writing data out */
 /* modelled after BSD's kernel structures */
 enum uio_rw {
 	UIO_READ,
 	UIO_WRITE
 };
 
 
-struct iovec {
+struct myiovec {
 	void	*iov_base;	/* base if this chunk		*/
 	size_t	 iov_len;	/* length			*/
 };
 
-
 /* this is consumed !! i.e. keep a copy */
 struct uio {
-	struct	iovec *uio_iov;	/* pointer to array of iovecs	*/
+	struct	myiovec *uio_iov;	/* pointer to array of iovecs	*/
 	int	uio_iovcnt;	/* number of iovecs in array	*/
 	off_t	uio_offset;	/* current offset		*/
 	size_t	uio_resid;	/* residual i/o count		*/
 	enum	uio_rw uio_rw;	/* read/write direction		*/
 	/* ... rest obmitted ... */
 };
 
 
 #endif	/* _SYS_UIO_H_ */
 
+
 /* allways declare the functions */
 
 
 /* move data from/to a uio structure to a blob */
 extern int uiomove(void *buf, size_t amount, struct uio *uio);
 
 
 /* end of uio.h */
